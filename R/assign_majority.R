#' Improve functional assignment based on a partial PR2 taxonomic path and majority rule
#'
#' Read a data.frame generated with \code{\link{assign_path}} and assign unassigned taxonomic path to function if a majority of species in the taxonomic path share the same functional information.
#'
#' @param x a data-frame as produced by \code{\link{assign_path}}
#' @param threshold a species percentage threshold above which functional information of the majority of species in a clade are assigned to a taxonomic path
#' @param ref the condense database for performing the functional assignment, should be the same as used for \code{\link{assign_path}}, default to \code{\link{DBc}}
#' @param sep separator character used to separate taxonomic ranks in the taxonomic path
#' @param empty_string a vector of element accepted for missing taxonomic information at a single taxonomic rank
#' @details
#' Using ref parameter, other database can be used to assign a function
#' @return a data-frame composed of:
#' \itemize{
#'   \item{}{taxonomy: the input taxonomy path}
#'   \item{}{all other columns of `x` not generated by \code{\link{assign_path}}}
#'   \item{}{assigned_from: the matched taxonomy path in the condensed database}
#'   \item{}{assigned_at_rank: the deepest taxonomic rank name of the matched taxonomy path}
#'   \item{}{assigned_from_taxa: the deepest clade name of the matched taxonomy path}
#'   \item{}{all the columns of the selected SoilEukFunc database containing the functional informations}
#'   \item{}{confidence: the percentage of species with identical functional informations in the clade described by assigned_from_taxa}
#' }
#' @seealso \code{\link{assign_path}}, \code{\link{DBc}}, \code{\link{DBc_main}}
#' @examples
#' fe <- assign_path(taxo_exa2, ref=DBc_main)
#' fx <- assign_majority(fe, ref=DBc_main, threshold=90)
#' dplyr::count(fe, main_functional_class, secondary_functional_class)
#' dplyr::count(fx, main_functional_class, secondary_functional_class)
#' @import dplyr
#' @importFrom magrittr %>%
#' @importFrom rlang .data
#' @importFrom plyr ldply
#' @importFrom stats setNames
#' @importFrom tibble add_row
#' @export
assign_majority<-function(x, threshold=95, ref=DBc, sep=";", empty_string=c(NA, "NA", "", " ")) {
  if ( ! is.data.frame(x) ) {
    stop("input have to be a data.frame")
  } else if ( ! "assigned_from" %in% colnames(x) ) {
    stop("input data.frame have to be the output of assign_path function")
  }
  if ( threshold < 50 ) {
    stop("threshold cannot be set below 50")
  } else if ( threshold > 99 ) {
    stop("threshold cannot be set above 99")
  }
  nx<-mutate(x,row=row_number()) %>%
    filter(is.na(.data$assigned_from) | .data$main_functional_class=="unknown")
  ax<-strsplit(unique(sub("(;NA)*$","",sub(";*$", "", gsub(sep, ";", gsub(".:", "", nx$taxonomy))))),";") %>%
    ldply(function(y) {
      out<-NULL
      for(i in length(y):1) {
        tmp<-filter(ref,grepl(paste(y[1:i],collapse=";"),.data$taxonomy)) %>%
          summarize(count=sum(count),.by=colnames(ref)[2:(ncol(ref)-3)]) %>%
          mutate(confidence=round(count/sum(count)*100,digits=1)) %>%
          select(-count) %>%
          filter(.data$confidence >= threshold)
        if( nrow(tmp) == 1 ) {
          out<-data.frame(taxonomy=paste(y,collapse=";"),
                          assigned_from=paste(y[1:i],collapse=";"),
                          assigned_at_rank=taxonomic_ranks[i],
                          assigned_from_taxa=y[i],
                          tmp)
          break
        }
      }
      if ( is.null(out) ) {
        return(data.frame(taxonomy=paste(y,collapse=";"),
                          as.data.frame.list(setNames(rep(NA,ncol(tmp)+3),
                                                      c("assigned_from",colnames(tmp),"assigned_at_rank","assigned_from_taxa")))))
      } else {
        return(out)
      }
    })
  # new assignments
  new<-select(nx, -any_of(intersect(colnames(nx),colnames(select(ax, - .data$taxonomy))))) %>%
    left_join(ax,by="taxonomy")
  # integrate back rows with new values
  mutate(x,row=row_number(),confidence=NA) %>%
    filter(! row %in% new$row) %>%
    add_row(new) %>%
    arrange(row) %>%
    select(-row)
}
